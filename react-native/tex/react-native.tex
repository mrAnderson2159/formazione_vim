\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsfonts,amsmath,amssymb}
\usepackage{graphicx}
\usepackage{tcolorbox}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{float}
\usepackage{enumitem}
\usepackage{titlesec}
\usepackage{lmodern}
\usepackage{xcolor}

% Colori personalizzati
\definecolor{primary}{HTML}{2E86C1} % Blu moderno
\definecolor{secondary}{HTML}{117864} % Verde scuro
\definecolor{accent}{HTML}{D35400} % Arancione acceso
\definecolor{lightgray}{HTML}{F2F3F4} % Grigio chiaro per sfondi

% Impostazioni header e footer
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\textbf{\textcolor{primary}{React-Native}}}
\fancyhead[R]{\textcolor{secondary}{Valerio Molinari}}
\fancyfoot[C]{\thepage}

% Hyperlink
\hypersetup{
    colorlinks=true,
    linkcolor=primary,
    urlcolor=accent,
    citecolor=secondary
}

% Titoli stilizzati
\titleformat{\section}{\color{primary}\normalfont\Large\bfseries}{}{0em}{}
\titleformat{\subsection}{\color{secondary}\normalfont\large\bfseries}{}{0em}{}
\titleformat{\subsubsection}{\color{accent}\normalfont\normalsize\bfseries}{}{0em}{}

% Evidenziazione con box
\newtcolorbox{highlight}{colback=lightgray,colframe=primary!80!black,boxrule=0.5mm,arc=4mm,top=2mm,bottom=2mm,left=4mm,right=4mm}

% Spaziatura e interlinea
\setlength{\parskip}{1em}
\setlength{\parindent}{0pt}
\renewcommand{\baselinestretch}{1.5}

% Nuove definizioni
\newcommand{\important}[1]{\textcolor{accent}{\textbf{#1}}}

\begin{document}

% Copertina
\begin{titlepage}
\begin{center}
\vspace*{3cm}
\Huge\textcolor{primary}{\textbf{Formazione VIM}} \\[1cm]
\Large\textcolor{secondary}{Appunti di React-Native} \\[1cm]
\textcolor{accent}{Valerio Molinari}\\
\vfill
\today
\end{center}
\end{titlepage}

% Indice
\tableofcontents
\newpage

% Esempio di sezione
\section{Introduzione}
React-Native è un framework per lo sviluppo di applicazioni mobile, sviluppato da Facebook. 
Questo framework permette di creare applicazioni mobile per Android e iOS utilizzando JavaScript e React.

\subsection{Differenze tra React e React-Native}
Già dal principio possiamo notare alcune differenze tra i due linguaggi, soprattutto
per quanto riguarda i componenti. Infatti, mentre React utilizza componenti HTML, React-Native
utilizza componenti nativi per Android e iOS.

Laddove ad esempio in React si utilizza un tag \texttt{<div>}, in React-Native si utilizza un
\texttt{<View>}. Inoltre, mentre in React si utilizza un tag \texttt{<input>}, in React-Native si
utilizza un \texttt{<TextInput>} e così via.

Tutti i componenti di React-native possono essere trovati
e cosultati alla pagina \\\url{https://reactnative.dev/docs/components-and-apis}.

\subsection{Expo}
Expo è un framework che permette di sviluppare applicazioni React-Native senza la necessità di
installare Android Studio o XCode. Expo permette di testare le applicazioni dire
sul proprio smartphone, senza la necessità di emulatori.

Per iniziare a sviluppare con Expo, è sufficiente lanciare il comando
\begin{highlight}
\begin{verbatim}
npx create-expo-app@latest --template blank
\end{verbatim}
\end{highlight}
Usiamo \texttt{--template blank} per creare un progetto vuoto.


\section{Flexbox}
Flexbox è un sistema di layout che permette di organizzare gli elementi in una griglia flessibile.
In React-Native, Flexbox è il sistema di layout predefinito.

Il {\bf comportamento di default} consiste nell'organizzare una serie di elementi su 
una colonna. Quindi dato un container flex, gli elementi figli verranno disposti
{\bf uno sotto l'altro}.

Questo comportamento può essere modificato tramite la proprietà \texttt{flexDirection}.

\subsection{flexDirection}
Vediamo nel dettaglio le possibilità offerte da \texttt{flexDirection}:
\begin{itemize}
\item \texttt{column} (default): gli elementi vengono disposti uno sotto l'altro.
\item \texttt{row}: gli elementi vengono disposti uno accanto all'altro.
\item \texttt{row-reverse}: gli elementi vengono disposti uno accanto all'altro, ma in ordine inverso.
\item \texttt{column-reverse}: gli elementi vengono disposti uno sotto l'altro, ma in ordine inverso.
\item \texttt{wrap}: gli elementi vengono disposti su più righe.
\end{itemize}

\subsection{Dimensioni}
Se il contenitore non specifica le dimensioni, né le specificano i figli,
questi occuperanno esattamente lo spazio necessario per il loro contenuto.
Tuttavia se specifichiamo le dimensioni del contenitore, allora i figli
si adatteranno a queste dimensioni.

\subsection{Assi}

\subsection{Justify Content e Align Items}
\begin{itemize}
\item \texttt{justifyContent}: allinea gli elementi lungo l'asse principale.
\item \texttt{alignItems}: allinea gli elementi lungo l'asse trasversale.
\end{itemize}

Justify Content ha le seguenti proprietà:
\begin{itemize}
\item \texttt{flex-start}: allinea gli elementi all'inizio dell'asse principale.
\item \texttt{flex-end}: allinea gli elementi alla fine dell'asse principale.
\item \texttt{center}: allinea gli elementi al centro dell'asse principale.
\item \texttt{space-between}: distribuisce gli elementi in modo uniforme lungo l'asse principale.
\item \texttt{space-around}: distribuisce gli elementi in modo uniforme lungo l'asse principale, 
con spazi uguali all'inizio e alla fine.
\item \texttt{space-evenly}: distribuisce gli elementi in modo uniforme lungo l'asse principale, 
con spazi uguali tra gli elementi.
\end{itemize}

mentre Align Items ha le seguenti proprietà:
\begin{itemize}
\item \texttt{flex-start}: allinea gli elementi all'inizio dell'asse trasversale.
\item \texttt{flex-end}: allinea gli elementi alla fine dell'asse trasversale.
\item \texttt{center}: allinea gli elementi al centro dell'asse trasversale.
\item \texttt{stretch}: allunga gli elementi per riempire tutto lo spazio disponibile.
\item \texttt{baseline}: allinea gli elementi lungo la loro linea di base.
\end{itemize}

\subsection{Flex}
La proprietà \texttt{flex} permette di specificare la dimensione di un elemento in relazione
agli altri elementi. È affine al concetto di \textit{col-n} in Bootstrap.
Specifichiamo un valore numerico per la proprietà \texttt{flex} per indicare la proporzione
di spazio che l'elemento deve occupare rispetto agli altri elementi.
In altre parole se abbiamo due elementi con \texttt{flex: 1} e \texttt{flex: 2}, il secondo
elemento occuperà il doppio dello spazio del primo.


\section{ScrollView}
React-native, diversamente dal web, non produce uno scroll automatico
quando il contenuto è troppo grande per lo schermo. Per ottenere uno scroll
possiamo utilizzare il componente \texttt{ScrollView}. 

Questa componente offre alcune interessanti proprietà, alcune solo per iOS altre 
solo per Android. Ad esempio, possiamo utilizzare la proprietà \texttt{alwaysBounceVertical}
per abilitare lo scroll verticale anche quando non è necessario, o disattivarla se non
vogliamo avere il "rimbalzo" quando lo scroll non è stato riempito.

Come sempre possiamo trovare l'argomento nel dettaglio alla
\href{https://reactnative.dev/docs/scrollview#alwaysbouncevertical}{documentazione ufficiale di React-Native}.

\subsection{Performance}
ScrollView risulta ottima come componente quando la necessità
è quella di renderizzare un numero ben limitato di elementi.
La ragione è che ScrollView renderizza tutti gli elementi figli
in una volta sola, e quindi se abbiamo un numero elevato di elementi
la performance ne risentirà.

Per ovviare a questo problema possiamo utilizzare la componente \texttt{FlatList}.

\section{FlatList}
FlatList si usa quando il numero di elementi da visualizzare è elevato, 
e quello che fa è renderizzare immediatamente il contenuto visibile mentre carica in maniera lazy
il resto. 

Per funzionare ha bisogno di due funzioni fondamentali: \texttt{data} e \texttt{renderItem}.
La prima contiene i dati da visualizzare, mentre la seconda è una funzione che renderizza
ogni elemento della lista.

Vediamo un esempio: 
\begin{verbatim}
...
const dummyGoals = [...Array(20_000)].map((_, i) => `Goal ${i + 1}`);
const [goalList, setGoalList] = useState(dummyGoals);
...
<FlatList
    data={goalList}
    renderItem={(itemData) => (
        <Text style={styles.goalItem}>{itemData.item}</Text>
    )}
    alwaysBounceVertical={false}
/>
\end{verbatim}
Vediamo che FlatList.renderItem passa un oggetto itemData, che contieme metadata
sugli elementi della lista passata a data, goalList in questo caso




\section{Pressable}
Mentre in React o nel web in generale, qualsiasi 
elemento può essere generare un evento di click, in React-Native,
a parte i componenti Button, questo non è vero.

Per rendere una componente cliccabile, bisogna
wrapparla con il componente \texttt{Pressable}.
\begin{highlight}
\begin{verbatim}
<Pressable onPress={() => console.log('Pressed')}>
    <Text>Press me</Text>
</Pressable>
\end{verbatim}
\end{highlight}


\section{react-devtools}
Uno strumento molto utile per il debug di un'applicazione React-Native è
\texttt{react-devtools}. Questo strumento permette di ispezionare il codice
e lo stato di un'applicazione React-Native come se fosse una pagina web.

Lo installiamo su windows con 
\begin{highlight}
\begin{verbatim}
npm install -g react-devtools
\end{verbatim}  
\end{highlight}
e su macOS con
\begin{highlight}
\begin{verbatim}
sudo npm install -g react-devtools
\end{verbatim}
\end{highlight}

Per utilizzarlo, basta lanciare il comando
\begin{highlight}
\begin{verbatim}
react-devtools
\end{verbatim}
\end{highlight}
e aprire l'applicazione React-Native sul proprio dispositivo (o ricaricarla).





\section{Styling}
\subsection{Shadows}
Per aggiungere un'ombra abbiamo due approcci diversi a seconda del sistema operativo:
\begin{itemize}
\item Per iOS, possiamo utilizzare la proprietà \texttt{shadowColor}, \texttt{shadowOffset}, \texttt{shadowOpacity} e \texttt{shadowRadius}.
\item Per Android, possiamo utilizzare la proprietà \texttt{elevation}.
\item Per entrambi, possiamo utilizzare la proprietà \texttt{shadow} di React-Native.
\end{itemize}nh








\end{document}
